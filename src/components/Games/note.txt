import React, { useRef, useEffect, useState } from 'react';
import * as THREE from 'three';

const Games = () => {
  const [score, setScore] = useState({ player: 0, robot: 0 });

  // Set up the Three.js elements
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer();
  const paddleHeight = 20; // Paddle's height
  const paddle1 = new THREE.Mesh(new THREE.BoxGeometry(2, paddleHeight, 1), new THREE.MeshBasicMaterial({ color: 0xffffff }));
  const paddle2 = new THREE.Mesh(new THREE.BoxGeometry(2, paddleHeight, 1), new THREE.MeshBasicMaterial({ color: 0xffffff }));
  const ball = new THREE.Mesh(new THREE.SphereGeometry(2, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff }));

  let ballSpeed = { x: 0.2, y: 0.2 };
  let ballDirection = { x: 1, y: 1 };

  const mount = useRef(null);

  // Handler for window resizing
  const handleResize = () => {
    const width = window.innerWidth;
    const height = window.innerHeight;
    renderer.setSize(width, height);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
  };

  // Handler for player's paddle movement using arrow keys
  const handleKeyDown = (e) => {
    if (e.key === 'ArrowUp' && paddle1.position.y < window.innerHeight / 2 - paddleHeight / 2) {
      paddle1.position.y += 5;
    } else if (e.key === 'ArrowDown' && paddle1.position.y > -window.innerHeight / 2 + paddleHeight / 2) {
      paddle1.position.y -= 5;
    }

    renderer.render(scene, camera);
  };

  // Handler for collision between ball and paddles
  const handleCollision = () => {
    // Logic for collision with player's paddle
    if (
      ball.position.x <= paddle1.position.x + 1 && ball.position.y <= paddle1.position.y + paddleHeight / 2 &&
      ball.position.y >= paddle1.position.y - paddleHeight / 2
    ) {
      ballDirection.x *= -1;
    }

    // Logic for collision with robot's paddle
    if (
      ball.position.x >= paddle2.position.x - 1 && ball.position.y <= paddle2.position.y + paddleHeight / 2 &&
      ball.position.y >= paddle2.position.y - paddleHeight / 2
    ) {
      ballDirection.x *= -1;
    }

    // Logic for ball bouncing off the top and bottom walls
    if (ball.position.y >= 50 || ball.position.y <= -50) {
      ballDirection.y *= -1;
    }

    // Logic for scoring when the ball passes the paddles
    if (ball.position.x <= -45) {
      setScore({ ...score, robot: score.robot + 1 });
      resetBall();
      return;
    }
    if (ball.position.x >= 45) {
      setScore({ ...score, player: score.player + 1 });
      resetBall();
      return;
    }
  };

  // Reset the ball's position
  const resetBall = () => {
    ball.position.set(0, 0, 0);
    ballDirection = { x: Math.random() > 0.5 ? 1 : -1, y: Math.random() > 0.5 ? 1 : -1 };
  };

  // Logic for moving the robot's paddle
  const moveRobotPaddle = () => {
    if (paddle2.position.y < ball.position.y && paddle2.position.y < 20) {
      paddle2.position.y += 1;
    } else if (paddle2.position.y > ball.position.y && paddle2.position.y > -20) {
      paddle2.position.y -= 1;
    }
  };

  useEffect(() => {
    // Set up Three.js renderer and initial positions
    renderer.setSize(window.innerWidth, window.innerHeight);
    mount.current.appendChild(renderer.domElement);

    paddle1.position.set(-40, 0, 0);
    paddle2.position.set(40, 0, 0);
    ball.position.set(0, 0, 0);

    scene.add(paddle1);
    scene.add(paddle2);
    scene.add(ball);

    camera.position.z = 100;

    const animate = () => {
      const robotMoveInterval = setInterval(moveRobotPaddle, 100);

      const update = () => {
        ball.position.x += ballSpeed.x * ballDirection.x;
        ball.position.y += ballSpeed.y * ballDirection.y;
        handleCollision();
        renderer.render(scene, camera);
        requestAnimationFrame(update);
      };

      window.addEventListener('resize', handleResize);
      window.addEventListener('keydown', handleKeyDown);

      update();

      return () => {
        window.removeEventListener('resize', handleResize);
        window.removeEventListener('keydown', handleKeyDown);
        clearInterval(robotMoveInterval);
      };
    };

    animate();
  }, []);

  return (
    <div>
      <div ref={mount} style={{ width: '100%', height: '70vh' }} />
      <div style={{ position: 'absolute', top: '10px', left: '10px', color: '#fff' }}>
        Player: {score.player} | Robot: {score.robot}
      </div>
    </div>
  );
};

export default Games;
